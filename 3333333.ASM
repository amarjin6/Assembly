        org 100h


start:
                mov ah, 09h
                mov dx, inputA          ;предложение ввода ј
                int 21h

                mov ah, 0ah
                mov dx, strA            ;вводим первое число ј
                int 21h

                mov bx, dx              ;помещаем в bx ссылку на строку в качестве передачи регистра как параметра процедуры
                call count_number       ;извлекаем из строки число ј
                push ax                 ;результат из регистра ах помещаем в стек

                mov ah, 02h
                mov dx, 0x0D0A
                int 21h

                mov ah, 09h
                mov dx, inputB          ;предложение ввода ¬
                int 21h

                mov ah, 0ah
                mov dx, strB            ;вводим второе число ¬
                int 21h

                mov bx, dx
                call count_number       ;извлекаем из строки число ¬
                push ax                 ;результат из регистра ах в стек

                call get_result         ;получаем результат вычислений


                mov ax, [res]           ;перемещаем в ах результат дл€ последующего вывода ответ
                call output_number      ;вывод ответа

                pop ax                  ;чистим стек
                pop ax

                mov ah, 08h
                int 21h                 ;конец основной части программы
                ret

count_number:                    ;процедура получени€ числа из строки
                xor ax, ax      ;обнул€ем ах
                xor dx, dx      ;обнул€ем dx

                add bx, 1h      ;передвигаем адрес строки на 1
                mov cl, [bx]    ;захватываем 1 байт, в котором находитс€ фактическа€ длина строки

lp:                             ;цикл получени€ числа
                inc bx          ;увеличиваем указатель на строку на 1
                mul [cm]        ;умножаем на 10
                add al, [bx]    ;прибавл€ем цифру
                sub ax, '0'     ;убираем код '0'

                loop lp         ;уменьшаем регистр сх на 1, сравниваем с нулем, если не ноль, то повтор€ем цикл



                ret


output_number:                   ;процедура вывода числа на экран
                push '*'        ;запоминаем, что концом числа в стеке будет символ *

lpt:                            ;цикл разбиени€ числа на цифры и передача его в стек
                div [cm]        ;деление числа на 10, остаток уходит в dx
                push dx         ;добавл€ем в стек остаток от делени€
                xor dx, dx      ;очищаем dx от уже занесенного результата
                cmp ax, 0h      ;сравниваем результат делени€ с 0
                jne lpt         ;если не 0, то заново цикл


                mov ah, 02h
                mov dx, 0x0D0A
                int 21h

lpp:                            ;цикл вывода числа
                pop bx          ;вытаскиваем число из стека

                cmp bx, '*'     ;если конец стека
                je endst        ;то выходим из цикла

                add bx, '0'     ;иначе добавл€ем '0' чтобы получить символ

                mov ah, 02h
                mov dx, bx      ;выводим символ
                int 21h

                jmp lpp         ;повтор€ем цикл

endst:          ret             ;выходим

get_result:
                mov bp, sp      ;в регистр bp передаем указатель на стек дл€ доступа к другим переменным стека

                mov ax, [bp+4]  ;в регистр ах передаем переменную ј
                mov bx, [bp+2]  ;в регистр ax передаем переменную ¬
                add bx, ax      ;
                mov [res], bx   ;сохран€ем результат

                ret             ;выходим из процедуры





inputA          db "Enter number A: $"
inputB          db "Enter number B: $"
outputRes       db "A+B = $"
strA            db 10, 0, 10 dup(?)
strB            db 10, 0, 10 dup(?)
numA            dw 0h
numB            dw 0h
cm              dw 10
res             dw 0h

